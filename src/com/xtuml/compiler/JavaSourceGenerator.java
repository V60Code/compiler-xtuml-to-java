package com.xtuml.compiler;

import com.xtuml.compiler.model.Attribute;
import com.xtuml.compiler.model.MetaModel;
import com.xtuml.compiler.model.ModelClass;
import com.xtuml.compiler.model.XtUmlModelElement;

import java.util.HashMap;
import java.util.Map;

/**
 * Generates Java source code for the xtUML model classes.
 */
public class JavaSourceGenerator {

    public Map<String, String> generateSources(MetaModel model) {
        Map<String, String> sources = new HashMap<>();

        if (model.getModel() == null)
            return sources;

        for (XtUmlModelElement element : model.getModel()) {
            if (element instanceof ModelClass) {
                ModelClass clazz = (ModelClass) element;
                String className = clazz.getClassName();
                
                // [VALIDATION] Prevent Duplicate Class Names
                if (sources.containsKey(className)) {
                    throw new RuntimeException("COMPILER ERROR: Duplicate class definition found for '" + className + "'. Compilation halted.");
                }

                String source = generateClass(clazz);
                sources.put(className, source);
            }
        }
        return sources;
    }

    private String generateClass(ModelClass clazz) {
        StringBuilder sb = new StringBuilder();

        // 1. Package
        sb.append("package com.xtuml.generated;\n\n");

        // Imports
        sb.append("import com.xtuml.runtime.BaseModel;\n");
        sb.append("import com.xtuml.runtime.ObjectBroker;\n");
        sb.append("import com.xtuml.runtime.RelationshipManager;\n");
        sb.append("import com.xtuml.runtime.XtUmlEvent;\n");
        sb.append("import java.util.UUID;\n");
        sb.append("import java.time.LocalDateTime;\n");
        sb.append("\n");

        // 2. Class Definition
        sb.append("        // [CRITERIA 1] Handle Class Generation\n");
        sb.append("// Generated by xtUML Compiler\n");
        sb.append("// Class ID: ").append(clazz.getClassId()).append("\n");

        String extendsClause = "BaseModel";
        // [CRITERIA 4] Generalisasi & Spesialisasi (Inheritance)
        // If 'supertype' is defined in JSON, we generate 'extends SuperType'
        if (clazz.getSupertype() != null && !clazz.getSupertype().isEmpty()) {
            extendsClause = clazz.getSupertype();
        }

        sb.append("public class ").append(clazz.getClassName()).append(" extends ").append(extendsClause)
                .append(" {\n\n");

        // 2a. Event Constants
        if (clazz.getStates() != null) {
            sb.append("    // Event Constants\n");
            Map<String, Integer> eventIds = new HashMap<>();
            for (com.xtuml.compiler.model.State s : clazz.getStates()) {
                if (s.getStateEvents() != null) {
                    for (String evt : s.getStateEvents()) {
                        if (!eventIds.containsKey(evt)) {
                            eventIds.put(evt, Math.abs(evt.hashCode()) % 10000);
                        }
                    }
                }
            }

            for (Map.Entry<String, Integer> entry : eventIds.entrySet()) {
                sb.append("    public static final int EVENT_").append(entry.getKey().toUpperCase()).append(" = ")
                        .append(entry.getValue()).append(";\n");
            }
            sb.append("\n");
        }

        // 2b. State Enum
        if (clazz.getStates() != null && !clazz.getStates().isEmpty()) {
            sb.append("    // State Enum\n");
            sb.append("    public enum State {\n");
            for (int i = 0; i < clazz.getStates().size(); i++) {
                com.xtuml.compiler.model.State s = clazz.getStates().get(i);
                sb.append("        ").append(s.getStateName().toUpperCase().replaceAll("\\s+", "_"));
                if (i < clazz.getStates().size() - 1)
                    sb.append(",");
                sb.append("\n");
            }
            sb.append("    }\n\n");

            sb.append("    private State currentState;\n\n");
        }

        // 3. Fields
        if (clazz.getAttributes() != null) {
            sb.append("    // Attributes\n");
            for (Attribute attr : clazz.getAttributes()) {
                String javaType = mapType(attr.getDataType());
                String name = attr.getAttributeName();
                sb.append("    private ").append(javaType).append(" ").append(name).append(";\n");
            }
        }
        sb.append("\n");

        // 4. Constructor
        sb.append("    // Constructor\n");
        sb.append("    public ").append(clazz.getClassName()).append("() {\n");
        sb.append("        super();\n");
        sb.append("        ObjectBroker.getInstance().add(this);\n");
        // Initialize state
        if (clazz.getStates() != null && !clazz.getStates().isEmpty()) {
            String firstState = clazz.getStates().get(0).getStateName().toUpperCase().replaceAll("\\s+", "_");
            sb.append("        this.currentState = State.").append(firstState).append(";\n");
        }
        sb.append("    }\n\n");

        // 5. Methods - Getters/Setters
        if (clazz.getAttributes() != null) {
            sb.append("    // Getters and Setters\n");
            for (Attribute attr : clazz.getAttributes()) {
                String javaType = mapType(attr.getDataType());
                String name = attr.getAttributeName();
                String capitalized = name.substring(0, 1).toUpperCase() + name.substring(1);

                sb.append("    public ").append(javaType).append(" get").append(capitalized).append("() {\n");
                sb.append("        return this.").append(name).append(";\n");
                sb.append("    }\n\n");

                sb.append("    public void set").append(capitalized).append("(").append(javaType).append(" ")
                        .append(name).append(") {\n");
                sb.append("        this.").append(name).append(" = ").append(name).append(";\n");
                sb.append("    }\n\n");
            }
        }

        // 5b. State Machine Logic (processEvent override)
        // [CRITERIA 5] State Machine Translation
        // Translates logic: switch(state) -> if(event) -> action()
        if (clazz.getStates() != null && !clazz.getStates().isEmpty()) {
            sb.append("    // State Machine Processing Loop\n");
            sb.append("    @Override\n");
            sb.append("    public void processEvent(XtUmlEvent e) {\n");
            sb.append("        switch (currentState) {\n");

            Map<String, com.xtuml.compiler.model.State> eventToTargetState = new HashMap<>();
            for (com.xtuml.compiler.model.State s : clazz.getStates()) {
                if (s.getStateEvents() != null) {
                    for (String evt : s.getStateEvents()) {
                        eventToTargetState.put(evt, s);
                    }
                }
            }

            for (com.xtuml.compiler.model.State s : clazz.getStates()) {
                String stateEnum = s.getStateName().toUpperCase().replaceAll("\\s+", "_");
                sb.append("            case ").append(stateEnum).append(":\n");

                boolean firstEvent = true;
                for (Map.Entry<String, com.xtuml.compiler.model.State> trans : eventToTargetState.entrySet()) {
                    String evtName = trans.getKey();
                    com.xtuml.compiler.model.State targetState = trans.getValue();
                    String targetEnum = targetState.getStateName().toUpperCase().replaceAll("\\s+", "_");

                    if (firstEvent)
                        sb.append("                if ");
                    else
                        sb.append("                else if ");

                    sb.append("(e.getEventId() == EVENT_").append(evtName.toUpperCase()).append(") {\n");
                    sb.append("                    action_").append(targetEnum).append("(e);\n");
                    sb.append("                    this.currentState = State.").append(targetEnum).append(";\n");
                    sb.append("                }\n");

                    firstEvent = false;
                }
                sb.append("                break;\n");
            }
            sb.append("        }\n");
            sb.append("    }\n\n");

            // Generate private action methods
            generateStateMethods(sb, clazz);
        }

        // 5c. Operations (New Requirement)
        if (clazz.getOperations() != null) {
            sb.append("    // Operations\n");
            ActionTranslator translator = new ActionTranslator();
            for (com.xtuml.compiler.model.Operation op : clazz.getOperations()) {
                String retType = mapType(op.getReturnType());
                sb.append("    public ").append(retType).append(" ").append(op.getName()).append("() {\n");

                if (op.getAction() != null) {
                    String[] lines = op.getAction().split(";");
                    for (String line : lines) {
                        if (!line.trim().isEmpty()) {
                            sb.append("        ").append(translator.translateAction(line.trim())).append("\n");
                        }
                    }
                }

                // Safety return if not void and not returned in OAL (compiler limit)
                if (!"void".equals(retType)) {
                    sb.append("        return 0; // Placeholder return\n");
                }
                sb.append("    }\n\n");
            }
        }

        // 6. Delete Override
        sb.append("    // Logical Deletion\n");
        sb.append("    @Override\n");
        sb.append("    public void delete() {\n");
        sb.append("        ObjectBroker.getInstance().remove(this);\n");
        sb.append("        super.delete();\n");
        sb.append("    }\n");

        sb.append("}\n");
        return sb.toString();
    }

    private void generateStateMethods(StringBuilder sb, ModelClass clazz) {
        if (clazz.getStates() == null)
            return;

        // [CRITERIA 5] Auto-Sync State Attribute
        // Detect if there is an attribute of type 'state' (e.g., availability)
        String stateAttr = null;
        if (clazz.getAttributes() != null) {
            for (Attribute attr : clazz.getAttributes()) {
                if ("state".equalsIgnoreCase(attr.getDataType())) {
                    stateAttr = attr.getAttributeName();
                    break;
                }
            }
        }

        ActionTranslator translator = new ActionTranslator();

        for (com.xtuml.compiler.model.State state : clazz.getStates()) {
            String stateEnum = state.getStateName().toUpperCase().replaceAll("\\s+", "_");
            String methodName = "action_" + stateEnum;

            sb.append("    private void ").append(methodName).append("(XtUmlEvent rcvd_evt) {\n");
            
            // Inject State Attribute Update
            if (stateAttr != null && state.getStateValue() != null) {
                 sb.append("        this.").append(stateAttr).append(" = \"").append(state.getStateValue()).append("\";\n");
            }

            sb.append("        System.out.println(\"Entering state: ").append(stateEnum).append("\");\n");

            // Logic Injection from JSON
            if (state.getAction() != null && !state.getAction().isEmpty()) {
                String[] lines = state.getAction().split(";");
                for (String line : lines) {
                    if (!line.trim().isEmpty()) {
                        String javaCode = translator.translateAction(line.trim());
                        sb.append("        ").append(javaCode).append("\n");
                    }
                }
            } else {
                sb.append("        // No actions defined in model\n");
            }

            sb.append("    }\n\n");
        }
    }

    // [CRITERIA 8] Mapping OAL Code -> Java Types (52)
    private String mapType(String xtUmlType) {
        if (xtUmlType == null)
            return "String"; // Safety fallback
        switch (xtUmlType.toLowerCase()) {
            case "integer":
                return "int"; // [CRITERIA 1b] Type Data: integer -> int
            case "real":
            case "decimal":
                return "double"; // [CRITERIA 1b] Type Data: real -> double
            case "string":
                return "String"; // [CRITERIA 1b] Type Data: string -> String
            case "boolean":
                return "boolean";
            case "id":
                return "UUID"; // [CRITERIA 1b] Type Data: id -> UUID
            case "state":
                return "String";
            case "datetime":
                return "LocalDateTime";
            default:
                return "String";
        }
    }
}
